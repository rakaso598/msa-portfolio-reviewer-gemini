## 포트폴리오 리뷰어 API 상세 설계 가이드

### **1. 핵심 로직 흐름**

이 문서는 `msa-brain-gemini` 서비스 내 `analyze_portfolio` 엔드포인트의 **구현을 위한 상세 가이드**입니다. 다음의 핵심 논리적 흐름을 따라 개발을 진행합니다.

1.  **요청 데이터 유효성 검사**: 들어온 요청 본문(request body)의 `githubUrl`, `blogUrl`, `resumeText` 필드가 올바른 형식인지 확인합니다. 특히 `githubUrl`은 유효한 GitHub URL인지 검증해야 합니다.
2.  **데이터 수집 및 통합**:
    * **GitHub**: `githubUrl`을 기반으로 GitHub REST API 또는 GraphQL API를 사용하여 해당 저장소의 **최근 커밋 기록, 코드 파일 목록, README.md 파일 내용** 등을 가져옵니다.
    * **블로그**: `blogUrl`을 기반으로 웹 스크래핑(Web Scraping) 라이브러리를 사용해 블로그 글의 **본문 텍스트를 추출**합니다.
    * **이력서**: `resumeText`는 그대로 사용합니다.
    * 수집한 모든 데이터를 하나의 통합된 문자열로 만듭니다. 이 문자열에는 "다음은 GitHub 저장소의 README입니다: [README 내용]...", "다음은 블로그 글입니다: [블로그 내용]..."과 같은 명확한 구분자를 포함해야 AI가 각 정보를 정확히 인식할 수 있습니다.
3.  **AI 분석 요청**:
    * 통합된 문자열과 함께 **AI 프롬프트**를 구성합니다. 프롬프트는 "전문 개발자 채용 담당자 관점에서 다음 포트폴리오를 분석해줘"와 같은 명확한 역할 부여와 함께, "강점, 약점, 기술 피드백, 문서 피드백, 종합 점수를 반드시 JSON 형식으로 반환해줘"와 같은 **구체적인 출력 형식 제약**을 포함해야 합니다.
    * 이 프롬프트를 기존 Gemini AI 모듈에 전달하여 분석을 요청합니다.
4.  **응답 파싱 및 정제**:
    * AI로부터 받은 응답은 문자열 형태의 JSON이므로, 이를 **JSON 객체로 파싱**합니다. 파싱 과정에서 발생할 수 있는 오류(예: AI가 JSON 형식을 지키지 않은 경우)를 처리하는 로직이 필요합니다.
    * 파싱된 데이터의 유효성을 다시 한번 검증하고, 최종 응답 스키마에 맞게 정제합니다. 예를 들어, `overallScore`가 0-100 사이의 숫자인지 확인하는 로직을 추가할 수 있습니다.
5.  **응답 반환**: 최종적으로 정제된 JSON 객체를 HTTP 응답으로 반환합니다.

---

### **2. 기술 스택 및 라이브러리 (백엔드)**

* **웹 프레임워크**: **NestJS**.
* **외부 API 통신**: **`axios`** 또는 **`node-fetch`**를 사용해 GitHub REST API에 요청을 보냅니다. 인증이 필요한 경우 개인용 액세스 토큰(Personal Access Token)을 사용합니다.
* **웹 스크래핑**: **`cheerio`**, **`puppeteer`**, 또는 **`playwright`**와 같은 라이브러리를 사용해 블로그 URL에서 HTML을 파싱하고 텍스트를 추출합니다.
* **AI 프롬프트**: 프롬프트는 별도의 상수 파일에 저장하여 관리하는 것이 좋습니다. 여러 필드를 조합해서 동적으로 프롬프트를 생성하는 로직을 작성합니다.

---

### **3. 테스트 및 배포 고려 사항**

* **단위 테스트**: 각 비즈니스 로직(데이터 수집, 프롬프트 생성, 응답 파싱)을 독립적으로 테스트하는 코드를 작성합니다. 특히 에러 핸들링 로직에 대한 테스트를 강화해야 합니다.
* **통합 테스트**: 전체 엔드포인트(`analyze_portfolio`)를 호출하여 모든 로직이 유기적으로 잘 동작하는지 확인합니다. 실제 GitHub URL을 사용한 테스트 케이스를 포함하는 것이 좋습니다.
* **환경 변수 관리**: GitHub API 토큰, 블로그 스크래핑 관련 설정 등 민감한 정보는 환경 변수로 관리해야 합니다. `configService`를 사용하여 안전하게 로드합니다.
* **Rate Limiting**: 과도한 요청으로 인한 Gemini API 비용 발생을 막고, 서버 부하를 줄이기 위해 `nestjs-throttler`와 같은 모듈을 사용해 `Rate Limiting`을 적용합니다.

이 가이드만으로도 개발자는 구현에 필요한 핵심적인 방향과 기술적 디테일을 충분히 이해하고 개발을 시작할 수 있습니다. 